\chapter{Data Transfer}\label{chap:data-transfer}

\section{Introduction}

In this chapter, an algorithm for conservative data transfer between curved
meshes will be described. This has practical applications to many methods in
computational physics. Data transfer is needed when a solution (approximated
by a discrete field) is known on a \textbf{donor} mesh and must be transferred
to a \textbf{target} mesh. In many applications, the field must be conserved
for physical reasons, e.g. mass or energy cannot leave or enter the system,
hence the focus on \textbf{conservative} data transfer. A few
scenarios where data transfer is necessary will be considered below to
motivate the ``black box'' data transfer algorithm.

Since data transfer is so commonly needed in physical applications, this
problem of conservative interpolation has been considered already for
straight sided meshes. The \textbf{common refinement} approach in
\cite{Jiao2004} is used to compare several methods for data transfer across two
meshes. However, the problem of constructing a common refinement is
not discussed there. The problem of constructing such a refinement is
considered in \cite{Farrell2009, Farrell2011} (called a supermesh by
the authors).
However, the data transfer becomes considerably more challenging for curved
meshes. For a sense of the difference between the straight sided and curved
cases, consider the problem of intersecting an element from the donor mesh
with an element from the target mesh. If the elements are triangles, the
intersection is either a convex polygon or has measure zero. If the elements
are curved, the intersection can be non-convex and can even split into
multiple disjoint regions.

\subsection{Lagrangian Methods}

\begin{figure}
  \includegraphics{../images/curved-mesh/simple_transport.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{The solution to \(u_t + u_x = 0, \; u(x, 0) = x^3\) plotted in
    the \(xu\)-plane. Demonstrates simple transport of
    the solution.}
  \label{fig:simple-transport}
\end{figure}

The method of characteristics helps transform partial differential equations
into ordinary differential equations by dividing the physical domain into
a family of curves. For example, the simple transport equation
\begin{equation}\label{eq:simple-transport}
u_t + c u_x = 0
\end{equation}
can be transformed when restricting to the family of lines
\(x(t) = x_0 + c t\). On these lines \(u(x(t), t)\) is constant, by
construction, and so the solution is ``transported'' from \(u(x_0, 0)\)
along each characteristic line (Figure~\ref{fig:simple-transport}).

Motivated by this, \textbf{Lagrangian methods} treat each point in the
physical domain as a ``particle'' which moves along a characteristic curve
over time and then monitor values associated with the particle (heat / energy,
velocity, pressure, density, concentration, etc.). They are an effective way
to solve PDEs, even with higher order or non-linear terms.
For example, if a viscosity term is added to~\eqref{eq:simple-transport}
\begin{equation}
u_t + c u_x - \eps u_{xx} = 0
\end{equation}
then the same characteristics can be used, but the value
along each characteristic is no longer constant; instead it satisfies the
ODE \(\frac{d}{dt} u(x(t), t) = \eps u_{xx}\).

This approach transforms the numerical solution of PDEs into a family of
numerical solutions to many independent ODEs. It allows the use of familiar
and well understood ODE solvers. In addition, Lagrangian methods often
have less restrictive conditions on time steps than Eulerian
methods\footnote{In Eulerian methods, the mesh is fixed.}.
When solving PDEs on unstructured meshes
with Lagrangian methods, the nodes move (since they
are treated like particles) and the mesh ``travels''.

\subsection{Remeshing and Adaptivity}

\begin{figure}
  \includegraphics{../images/curved-mesh/mesh_distortion.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Distortion of a regular mesh caused by particle motion along
    the velocity field \(\left[ y^2 \; 1 \right]^T\) from \(t = 0\)
    to \(t = 1\) with \(\Delta t = 1/4\).}
  \label{fig:mesh-distortion}
\end{figure}

A flow-based change to a mesh can cause problems if it causes the mesh to
leave the domain being analyzed or if it distorts the mesh until the element
quality is too low in some mesh elements. Over enough time, the mesh can
even tangle (i.e. elements begin to overlap).
For an example of such distortion (Figure~\ref{fig:mesh-distortion}),
consider a PDE of the form
\begin{equation}\label{eq:non-rigid-characteristics}
u_t + \left[ \begin{array}{c} y^2 \\ 1 \end{array}\right] \cdot \nabla u +
  F\left(u, \nabla u\right) = 0.
\end{equation}
The characteristics \(y(t) = y_0 + t, x(t) = x_0 +
\left(y(t)^3 - y_0^3\right)/3\)
distort the mesh considerably after just one second.

\begin{figure}
  \includegraphics[width=0.9375\textwidth]
                  {../images/curved-mesh/distortion_remesh.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Remeshing a domain after distortion caused by particle motion
    along the velocity field \(\left[ y^2 \; 1 \right]^T\) from \(t = 0\)
    to \(t = 1\).}
  \label{fig:distortion-remesh}
\end{figure}

To deal with distortion, one can allow the mesh to adapt in between time
steps. For example, Figure~\ref{fig:distortion-remesh} shows an example
remeshing of the domain.
In addition to improving mesh quality, mesh
adaptivity can be used to dynamically focus computational effort to resolve
sensitive features of a numerical solution. From~\cite{Iske2004}
\begin{quote}
{\small In order to balance the method's approximation quality and its
computational costs effectively, adaptivity is an essential requirement,
especially when modelling multiscale phenomena.}
\end{quote}
For more on mesh adaptivity, see \cite{Babuska1978, Peraire1987, Pain2001}.

In either case, the change in the
mesh between time steps requires transferring a known solution on the
discarded mesh to the mesh produced by the remeshing process. Without
the ability to change the mesh, Lagrangian methods (or, more generally,
ALE~\cite{Hirt1974}) would not be useful, since after a limited time the
mesh will distort.

\subsection{High-order Meshes}

\begin{figure}
  \includegraphics[width=0.9375\textwidth]
                  {../images/curved-mesh/main_figure27.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Comparing straight sided meshes to a curved mesh when approximating
    the unit disc in \(\reals^2\).}
  \label{fig:curved-vs-straight-mesh}
\end{figure}

To allow for greater geometric flexibility and for high order of convergence,
curved mesh elements can be used in the finite element method. Though the
complexity of a method can steeply rise when allowing curved elements, the
trade for high-order convergence can be worth it. (See~\cite{Wang2013} for
more on high-order CFD methods.) Curved meshes can typically
represent a given geometry with far fewer elements than a straight sided mesh
(for example, Figure~\ref{fig:curved-vs-straight-mesh}).
The increase in accuracy also allows for the use of fewer elements, which
in turn can also facilitate a reduction in the overall computation time.

\begin{figure}
  \includegraphics{../images/curved-mesh/element_distortion.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Movement of nodes in a quadratic element under distortion caused
    by particle motion along the velocity field \(\left[ y^2 \; 1 \right]^T\)
    from \(t = 0\) to \(t = 1\) with \(\Delta t = 1/2\). The green curves
    represent the characteristics that each node travels along.}
  \label{fig:element-distortion}
\end{figure}

Even if the domain has no inherent curvature, high-order (degree \(p\)) shape
functions allow for order \(p + 1\) convergence, which is desirable in
it's own right. However, even in such cases, a Lagrangian method must either
curve the mesh or information about the flow of the geometry will be lost.
Figure~\ref{fig:element-distortion} shows what happens to a given
quadratic element as the nodes move along the
characteristics from~\eqref{eq:non-rigid-characteristics}.
This element uses the triangle vertices and edge
midpoints to determine the shape functions. However, as the nodes move
with the flow, the midpoints are no longer on the lines connecting
the vertex nodes. To allow the mesh to more accurately represent the
solution, the edges can instead curve so that the midpoint nodes remain
halfway between (i.e. half of the parameter space) the vertex nodes along
an edge.

%% However, the basis functions of the donor mesh
%% are (in general) discontinuous piecewise polynomials over any given
%% element of the target mesh, which are very difficult to integrate
%% by numerical quadrature schemes.

%% B\'{e}zier curves and triangles were selected for defining
%% mesh elements for two main reasons...
%% Secondly, B\'{e}zier curves and triangles have a
%% number of mathematical properties leading to elegant
%% algorithms.

%% Since adapting the mesh changes the domain for \(\bm{f}\), we
%% must project \(\bm{f}\) onto the new mesh domain. This is
%% accomplished by making local projections of \(\bm{f}\) whenever
%% local mesh modifications are made, and then computing
%% the local reinterpolation error. The choice of a
%% relevant error norm and projection is problem dependent,
%% but the computations are generally easy, since
%% they are done in a local setting with few degrees of
%% freedom. If the calculated re-interpolation error due
%% to a mesh modification is too great, then the modification
%% can be aborted and can be replaced with a mesh
%% refinement.

\subsection{Multiphysics and Comparing Methods}

In multiphysics simulations, a problem is partitioned into physical components.
This partitioning can apply to both the physical domain (e.g. separating a
solid and fluid at an interface) and the simulation data itself (e.g. solving
for pressure on one mesh and velocity on another). Each (multi-)physics
component is solved for on its own mesh. When the components interact, the
simulation data must be transferred between those meshes.

In a similar category of application, data transfer enables the comparison
of solutions defined on different meshes. For example, if a reference
solution is known on a very fine special-purpose mesh, the error can be
computed for a coarse mesh by transferring the solution from the fine
mesh and taking the difference. Or, if the same method is used on
different meshes of the same domain, the resulting computed solutions can
be compared via data transfer. Or, if two different methods use two
different meshes of the same domain.

\subsection{Local versus Global Transfer}

Conservative data transfer has been around since the advent of ALE,
and as a result much of the existing literature focuses on mesh-mesh
pairs that will occur during an ALE-based simulation. When flow-based
mesh distortion occurs, elements are typically ``flipped'' (e.g. a
diagonal is switched in a pair of elements) or elements are subdivided
or combined. These operations are inherently local, hence the data
transfer can be done locally across known neighbors. Typically, this
locality is crucial to data transfer methods. In \cite{Margolin2003},
the transfer is based on partitioning cells of the updated mesh into
components of elements from the old mesh and ``swept regions'' from
neighbouring elements. In \cite{Kucharik2008}, the (locally) changing
connectivity of the mesh is addressed. In \cite{Garimella2007}, the
local transfer is done on polyhedral meshes.

Global data transfer instead seeks to conserve the solution across
the whole mesh. It makes no assumptions about the relationship between
the donor and target meshes. The loss in local information makes
the mesh intersection problem more computationally expensive, but the
added flexibility reduces timestep restrictions since it allows remeshing
to be done less often. In \cite{Dukowicz1984, Dukowicz1987}, a global
transfer is enabled by transforming volume integrals to surface integrals
via the divergence theorem to reduce the complexity of the problem.

\subsection{Limitations}

\begin{figure}
  \includegraphics[width=0.96875\textwidth]
                  {../images/curved-mesh/main_figure29.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Partially overlapping meshes on a near identical domain. Both are
    linear meshes that approximate the unit disc in \(\reals^2\). The outermost
    columns show how the domain of each mesh can be expanded so they agree.}
  \label{fig:partially-overlapping}
\end{figure}

The method described in this work only applies to meshes in \(\reals^2\).
Application to meshes in \(\reals^3\) is a direction for future research,
though the geometric kernels (see Chapter~\ref{chap:bezier-intersection})
become significantly more challenging to describe and implement. In
addition, the method will assume that every element in the
target mesh is contained in the donor mesh. This ensures that the data
transfer is \textit{interpolation}. In the case where all target elements are
partially covered, \textit{extrapolation} could be used to extend a solution
outside the domain, but for totally uncovered elements there is no clear
correspondence to elements in the donor mesh.

The case of partially overlapping meshes can be addressed in particular
cases (i.e. with more information). For example, consider a problem
defined on \(\Omega = \reals^2\) and solution
that tends towards zero as points tend to infinity. A typical approach
may be to compute the solution on a circle of large enough radius and
consider the numerical solution to be zero outside the circle.
Figure~\ref{fig:partially-overlapping} shows how data transfer could be
performed in such cases when the meshes partially overlap: construct a
simple region containing both computational domains and then mesh the
newly introduced area. However, the assumption that the numerical solution
is zero in the newly introduced area is very specific and
a similar approach may not apply in other cases of partial overlap.

Some attempts (\cite{Berger1987, Chesshire1994, Cai1999}) have been
made to interpolate fluxes between overlapping meshes. These perform
an interpolation on the region common to both meshes and then numerically
solve the PDE to determine the values on the uncovered elements.

\section{Galerkin Projection}

\begin{figure}
  \includegraphics[width=0.8125\textwidth]
                  {../images/curved-mesh/main_figure00.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Mesh pair: donor mesh \(\mathcal{M}_D\) and
    target mesh \(\mathcal{M}_T\).}
  \label{fig:donor-target-pair}
\end{figure}

Consider a donor mesh \(\mathcal{M}_D\) with shape function basis
\(\phi_D^{(j)}\) and a known field \(\bm{q}_D = \sum_j d_j \phi_D^{(j)}\) and a
target mesh \(\mathcal{M}_T\) with shape function basis \(\phi_T^{(j)}\)
(Figure~\ref{fig:donor-target-pair}).
Each shape function \(\phi\) corresponds to a
given isoparametric curved element (see Section~\ref{sec:curved-elements})
\(\mathcal{T}\) in one of these meshes and has
\(\operatorname{supp}(\phi) = \mathcal{T}\).
Additionally, the shape functions are polynomial degree \(p\) (see
Section~\ref{subsec:shape-functions} for a discussion of shape functions),
but the degree of the donor mesh need not be the same as that of the
target mesh. We assume that both meshes cover the same domain \(\Omega \subset
\reals^2\), however we really only require the donor mesh to cover the
target mesh.

We seek the \(L_2\)-optimal interpolant \(\bm{q}_T = \sum_j t_j \phi_T^{(j)}\):
\begin{equation}
\left \lVert \bm{q}_T - \bm{q}_D \right \rVert_2 =
\min_{\bm{q} \in \mathcal{V}_T}
\left \lVert \bm{q} - \bm{q}_D \right \rVert_2
\end{equation}
where \(\mathcal{V}_T = \operatorname{Span}_j\left\{\phi_T^{(j)}\right\}\)
is the function space defined on the target mesh. Since this is optimal in
the \(L_2\) sense, by differentiating with respect to each \(t_j\) in
\(\bm{q}_T\) we find the weak form:
\begin{equation}
\int_{\Omega} \bm{q}_D \phi_T^{(j)} \, dV =
  \int_{\Omega} \bm{q}_T \phi_T^{(j)} \, dV, \qquad \text{for all} j.
\end{equation}
If the constant function \(1\) is contained in \(\mathcal{V}_T\),
conservation follows from the weak form and linearity of the integral
\begin{equation}
\int_{\Omega} \bm{q}_D \, dV =
  \int_{\Omega} \bm{q}_T \, dV.
\end{equation}
Expanding \(\bm{q}_D\) and \(\bm{q}_T\) with respect to their coefficients
\(\bm{d}\) and \(\bm{t}\), the weak form gives rise to a linear system
\begin{equation}\label{eq:weak-form-system}
M_T \bm{t} = M_{TD} \bm{d}.
\end{equation}
Here \(M_T\) is the mass matrix for
\(\mathcal{M}_T\) given by
\begin{equation}
\left(M_T\right)_{ij} = \int_{\Omega} \phi_T^{(i)} \phi_T^{(j)} \, dV.
\end{equation}
In the discontinuous Galerkin case, \(M_T\) is block diagonal with blocks
that correspond to each element, so \eqref{eq:weak-form-system} can be
solved locally on each element \(\mathcal{T}\) in the target mesh. By
construction, \(M_T\) is symmetric and sparse since \(\left(M_T\right)_{ij}\)
will be \(0\) unless \(\phi_T^{(i)}\) and \(\phi_T^{(j)}\) are supported
on the same element \(\mathcal{T}\). In the continuous case, \(M_T\) is
globally coupled since coefficients corresponding to boundary nodes interact
with multiple elements. The matrix \(M_{TD}\) is a ``mixed'' mass matrix
between the target and donor meshes:
\begin{equation}
\left(M_{TD}\right)_{ij} = \int_{\Omega} \phi_T^{(i)} \phi_D^{(j)} \, dV.
\end{equation}
Though boundary conditions can be imposed on the system by fixing boundary
values, this is equivalent to removing some of the basis functions which may
in term make the projection non-conservative. This is because the removed
basis functions may have been used in \(1 = \sum_j u_j \phi_{T}^{(j)}\).

Computing \(M_T\) is fairly straightforward since the (bidirectional) mapping
from elements \(\mathcal{T}\) to basis functions \(\phi_T^{(j)}\) supported
on those elements is known. When using shape functions in the
global coordinates basis (see Section~\ref{subsec:shape-functions}), the
integrand \(F = \phi_T^{(i)} \phi_T^{(j)}\) will be a polynomial of degree
\(2p\) on \(\reals^2\). The domain of integration \(\mathcal{T}
= b\left(\utri\right)\) is the image of a (degree \(p\)) map \(b(s, t)\)
from the unit triangle. Using substitution
\begin{equation}
\int_{b\left(\utri\right)} F(x, y) \, dx \, dy =
  \int_{\utri} \det(Db) F\left(x(s, t), y(s, t)\right) \, ds \, dt
\end{equation}
(we know the map preserves orientation, i.e. \(\det(Db)\) is positive).
Once transformed this way, a quadrature rule on the unit
triangle (\cite{Dunavant1985}) can be used.

On the other hand, computing \(M_{TD}\) is significantly more
challenging. This requires solving both a geometric problem ---
finding the region to integrate over --- and an analytic
problem --- computing the integrals. The integration can be done with
a quadrature rule, though finding this region is significantly
more difficult.

\section{Common Refinement}

\begin{figure}
  \includegraphics[width=0.8125\textwidth]
                  {../images/curved-mesh/main_figure02.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{All donor elements that cover a target element}
  \label{fig:target-elt-all-matching}
\end{figure}

Rather than computing \(M_{TD}\), the right-hand side
of~\eqref{eq:weak-form-system} can be computed directly via
\begin{equation}\label{eq:lumped-mixed-mass-matrix}
\left(M_{TD} \bm{d}\right)_j = \int_{\Omega} \phi_T^{(j)} \bm{q}_D \, dV.
\end{equation}
Any given \(\phi\) is supported on an element \(\mathcal{T}\) in the
target mesh. Since \(\bm{q}_D\) is piecewise defined over each element
\(\mathcal{T}'\) in the donor mesh, the
integral~\eqref{eq:lumped-mixed-mass-matrix} may be problematic.
In the continuous Galerkin case, \(\bm{q}_D\) need not be differentiable
across \(\mathcal{T}\) and in the discontinuous Galerkin case,
\(\bm{q}_D\) need not even be continuous. This necessitates a
partitioning of the domain:
\begin{equation}
\int_{\Omega} \phi \, \bm{q}_D \, dV =
  \int_{\mathcal{T}} \phi \, \bm{q}_D \, dV =
  \sum_{\mathcal{T}' \in \mathcal{M}_D} \int_{\mathcal{T} \cap \mathcal{T}'}
    \phi \left.\bm{q}_D\right|_{\mathcal{T}'} \, dV.
\end{equation}
In other words, the integral over \(\mathcal{T}\) splits into integrals
over intersections \(\mathcal{T} \cap \mathcal{T}'\) for all
\(\mathcal{T}'\) in the donor mesh that intersect \(\mathcal{T}\)
(Figure~\ref{fig:target-elt-all-matching}). Since both \(\phi\) and
\(\left.\bm{q}_D\right|_{\mathcal{T}'}\) are polynomials on
\(\mathcal{T} \cap \mathcal{T}'\), the integrals will be exact when
using a quadrature scheme of an appropriate degree of accuracy.
Without partitioning \(\mathcal{T}\), the integrand is not a polynomial
(in fact, possibly not smooth), so the quadrature cannot be exact.

In order to compute \(M_{TD} \bm{d}\), we'll need to compute the
\textbf{common refinement}, i.e. an intermediate mesh that contains
both the donor and target meshes. This will consist of all non-empty
\(\mathcal{T} \cap \mathcal{T}'\) as \(\mathcal{T}\) varies over
elements of the target mesh and \(\mathcal{T}'\) over elements of the
donor mesh. This requires solving three specific subproblems:
\begin{itemize}
%% H/T: https://tex.stackexchange.com/a/6086/32270
\itemsep 0em
\item Forming the region(s) of intersection between two elements that
  are B\'{e}zier triangles.
\item Finding all pairs of elements, one each from the target and donor mesh,
  that intersect.
\item Numerically integrating over a region of intersection between two
  elements.
\end{itemize}
The first subproblem has been addressed in Section~\ref{sec:intersect-bez-tri}
and the curved polygon region(s) of intersection have been described
in Section~\ref{subsec:curved-polygons}. The second will be considered
in Section~\ref{subsec:advancing-front} and the third in
in Section~\ref{subsec:tessellation-integration} below.

\subsection{Advancing Front}\label{subsec:advancing-front}

\begin{figure}
  \includegraphics[width=0.8125\textwidth]
                  {../images/curved-mesh/main_figure13.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Brute force search for a donor element \(\mathcal{T}'\) that matches
    a fixed target element \(\mathcal{T}\).}
  \label{fig:target-elt-brute-force}
\end{figure}

We seek to identify all pairs \(\mathcal{T}\) and \(\mathcal{T}'\) of
target and donor elements. The na\"{i}ve approach just considers every pair
of elements and takes \(\bigO{\left|\mathcal{M}_D\right|
\left|\mathcal{M}_T\right|}\) to complete.\footnote{For a mesh \(\mathcal{M}\),
the expression \(\left|\mathcal{M}\right|\) represents the number of elements
in the mesh.} Taking after \cite{Farrell2011}, we can do much better than this
quadratic time search. In fact, we can compute all integrals in
\(\bigO{\left|\mathcal{M}_D\right| + \left|\mathcal{M}_T\right|}\).
First, we fix an element of the target mesh and perform a brute-force search
to find an intersecting element in the donor mesh
(Figure~\ref{fig:target-elt-brute-force}). This has worst-case time
\(\bigO{\left|\mathcal{M}_D\right|}\).

\begin{figure}
  \includegraphics[width=0.8125\textwidth]
                  {../images/curved-mesh/main_figure14.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{All donor elements \(\mathcal{T}'\) that cover a target element
    \(\mathcal{T}\), with an extra layer of neighbors in the donor mesh
    that \textbf{do not} intersect \(\mathcal{T}\).}
  \label{fig:target-elt-overlap-extra-layer}
\end{figure}

Once we have such a match, we use the connectivity of the
donor mesh to perform a breadth first search
for neighbors that also intersect the target
element \(\mathcal{T}\) (Figure~\ref{fig:target-elt-overlap-extra-layer}).
This search takes \(\bigO{1}\) time. It's also worthwhile to keep the first
layer of donor elements that don't intersect \(\mathcal{T}\) because they are
more likely to intersect the neighbors of \(\mathcal{T}\)\footnote{In the
very unlikely case that the boundary of \(\mathcal{T}\)
\textbf{exactly matches} the boundaries of the donor elements that cover it,
\textbf{none} of the overlapping donor elements can intersect the neighbors of
\(\mathcal{T}\) so the first layer of non-intersected donor
elements must be considered.}. Using the list of intersected elements, a
neighbor of \(\mathcal{T}\) can find a donor element it intersects with in
\(\bigO{1}\) time (Figure~\ref{fig:target-elt-neighbor}).
As seen, after our \(\bigO{\left|\mathcal{M}_D\right|}\)
initial brute-force search, the localized intersections for each
target element \(\mathcal{T}\) take
\(\bigO{1}\) time. So together, the process takes
\(\bigO{\left|\mathcal{M}_D\right| + \left|\mathcal{M}_T\right|}\).

For special cases, e.g. ALE methods, the initial brute-force search
can be reduced to \(\bigO{1}\). This could be enabled by tracking
the remeshing process so a correspondence already exists. If a full
mapping from donor to target mesh exists, the process of computing
\(M_T\) and \(M_{TD} \bm{d}\) can be fully parallelized across
elements of the target mesh, or even across shape functions
\(\phi_T^{(j)}\).

\begin{figure}
  \includegraphics[width=0.8125\textwidth]
                  {../images/curved-mesh/main_figure15.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{First match between a neighbor of the previously considered
    target element and all the donor elements that match the
    previously considered target element.}
  \label{fig:target-elt-neighbor}
\end{figure}

\subsection{Tessellation and Integration over Curved Polygons}
\label{subsec:tessellation-integration}

Integrate.

\subsection{Curved versus Polygonal Computing}

\begin{figure}
  \includegraphics[width=0.9375\textwidth]
                  {../images/curved-mesh/polygon_vs_curved.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Comparing the relative error for the computed area of a quadratic
    B\'{e}zier triangle. In one method, the curved boundary is used with
    Green's method and it is correct to machine precision. In the other,
    the curved edges are approximated by polygonal paths. These paths are
    generated from equally spaced parameters, for example a B\'{e}zier curve
    \(b(s)\) with \(N = 4\) would be approximated by a line connecting
    \(b(0), b(1/4), b(1/2), b(3/4)\) and \(b(1)\).}
  \label{fig:polygon-vs-curved}
\end{figure}

\begin{figure}
  \includegraphics[width=0.9375\textwidth]
                  {../images/curved-mesh/polygon_vs_curved_intersection.pdf}
  \centering
  \captionsetup{width=.75\linewidth}
  \caption{Comparing the relative error for the computed area of the
    intersection of two quadratic B\'{e}zier triangles. In one method, the
    intersection boundary is fully specified as the union of B\'{e}zier curve
    segments and the area is found via Green's method. This method is correct
    to machine precision. In the other, the curved edges are approximated by
    polygonal paths and the intersection of the resulting polygons is computed.
    These paths are generated from equally spaced parameters, for example a
    B\'{e}zier curve \(b(s)\) with \(N = 4\) would be approximated by a line
    connecting \(b(0), b(1/4), b(1/2), b(3/4)\) and \(b(1)\).}
  \label{fig:polygon-vs-curved-intersection}
\end{figure}
